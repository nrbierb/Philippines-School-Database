#Copyright 2010,2011 Neal R Bierbaum, Redtreefalcon Software
#This file is part of SchoolsDatabase.

#SchoolsDatabase is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.

#SchoolsDatabase  is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.

#You should have received a copy of the GNU General Public License
#along with SchoolsDatabase.  If not, see <http://www.gnu.org/licenses/>.

"""
This file is the interface to all Ajax web actions. All Ajax requests
are handled by the an AjaxServer object for both request and response.
Ajax requests are either served within this file or directed elsewhere
for generated the response contents. Many responses include Google
Visualization Tables generated by the google file gviz_api
"""

import exceptions, re
import logging
from datetime import date, timedelta
from google.appengine.ext import db
import django
from django import http
from django.utils import simplejson
import settings
import SchoolDB
import SchoolDB.utility_functions
import SchoolDB.student_attendance

class AjaxError(exceptions.Exception):
    def __init__(self, args=None):
        self.args = args

class AJAXSimpleExceptionResponse:
    def process_exception(self, request, exception):
        if settings.DEBUG:
            if request.is_ajax():
                import sys, traceback
                (exc_type, exc_info, tb) = sys.exc_info()
                response = "%s\n" % exc_type.__name__
                response += "%s\n\n" % exc_info
                response += "TRACEBACK:\n"    
                for tb in traceback.format_tb(tb):
                    response += "%s\n" % tb
                return http.HttpResponseServerError(response)

class AjaxServer():
    def __init__(self, request):
        self.request = request
        self.action = request.path.split("/")[2]
        if request.method == "POST":
            self.argsDict = self.request.POST.copy()
        else:
            self.argsDict = self.request.GET.copy()
        self.target_class = None
        self.target_object = None
        self.secondary_class = None
        self.secondary_object = None
        self.extra_fields = []   
        self.request_dict = None
        self.return_string = simplejson.dumps("")
        self.action_mapping = {
            "select":self._select,
            "select_via_function":self._select_via_function,
            "select_table":self._select_table,
            "generated_table":self._generated_object_table,
            "calculated_table":self._calculated_table,
            "set_single_value":self._set_single_value,
            "children_list":self._children_list,
            "delete_instance":self._delete_instance,
            "set_user_preferences":self._set_user_preferences,
            "get_user_preferences":self._get_user_preferences,
            "students_family_key":self._students_family_key,
            "students_family":self._students_family,
            "create_family":self._create_family,
            
            "cleanup_family":self._cleanup_family,
            "suggest_siblings":self._suggest_siblings,
            "find_similar_students":self._find_similar_students,
            "show_full_history":self._show_full_history,
            "get_attendance":self._get_attendance,
            "set_attendance":self._set_attendance,
            "get_calendar":self._get_calendar,
            "set_schoolday_date":self._set_schoolday_date,
            "get_grades":self._get_grades,
            "set_grades":self._set_grades,
            "get_achievement_test_grading_instances":\
              self._get_achievement_test_grading_instances,
            "get_achievement_tests_for_section":\
              self._get_achievement_tests_for_section,
            "get_subjects_for_achievement_test":\
              self._get_subjects_for_achievement_test,
            "edit_grading_period_grades":self._edit_grading_period_grades,
            "get_gradebook_entries":self._get_gradebook_entries,
            "change_date":self._change_date,
            "create_class_sessions":self._create_class_sessions,
            "generate_dialog_content":self._generate_dialog_content
        }
        self.error_string = ""
        
    def process_request(self):
        """
        This is the only external call for this class. The request user
        validated and the arguments from the request are parsed and
        translated into internal objects. The action to be performed is
        mapped from the text value in the request to the appropiate
        class function. Then the class function is called to generate
        the string that is the ajax return value. All actions are run
        within the single try block. All functions internal to this
        raise an "AjaxError" with the appropriate message ewhenever
        there is a problem that would prevent a useful response.
        """
        try:
            if (not self.request.is_ajax()):
                return http.HttpResponseBadRequest(
                    "Invalid or Non Ajax request.")
            self._preprocess_request()
            self.action_server = self.action_mapping.get(self.action, 
                                self._unknown_action)
            self.action_server()
            return http.HttpResponse(self.return_string, 
                        content_type="application/json; charset=utf-8")
        except AjaxError, e:
            error_string = repr(e)  
            logging.error(self.error_string)
            return http.HttpResponseServerError(self.error_string)
        #except StandardError, e:
            #error_string = "Serious error: " + str(e)
            #logging.error(error_string)
            #return http.HttpResponseServerError(error_string)
    
    def _validate_argsDict(self):
        """
        Check the values in the args dict for basic validity. Confirm
        that all dict keys are alphnumeric characters only and are of
        reasonable length. Raise an AjaxException if a test is not passed.
        """
        safe_size = 100
        for key in self.argsDict.keys():
            if ((len(key) > safe_size) or re.search(r'[^\w\-]', key)):
                raise AjaxError('Invalid key')
            
    def _preprocess_request(self):
        """
        Load the common parts from the request.GET dictionary
        and confirm basic validity. Generate error return string 
        problem. Not all values are required for all actions so
        no error is reported if they are missing
        """
        self._validate_argsDict()
        self.target_class = self._get_class('class')
        key_string = SchoolDB.views.filter_keystring(
            self.argsDict.get('key', None))
        self.target_object = self._get_object(self.target_class,
                                              key_string)
        if (self.target_class):
            SchoolDB.views.validate_action("View", 
                self._return_ajax_permissions_error, 
                self.target_class, self.target_object)
        self.secondary_class = self._get_class('secondary_class')
        key_string = SchoolDB.views.filter_keystring(
            self.argsDict.get('secondary_key', None))
        self.secondary_object = self._get_object(self.secondary_class,
                                              key_string)        
        self.function_name = self.argsDict.get('function', '')
        extra_fields_string = self.argsDict.get('extra_fields', None)
        if (extra_fields_string):
            self.extra_fields = extra_fields_string.split("|")
    
    def _get_class(self, field_name):
        class_name = self.argsDict.get(field_name, None)
        if (class_name):
            class_type = \
                    SchoolDB.models.get_model_class_from_name(class_name)
            if (not class_type):
                e = 'Unknown data type "%s" in ajax  %s request.' \
                    %(str(class_name), str(self.action))
                raise AjaxError, e
            return class_type
        else:
            return None
    
    def _get_object(self, object_class, key_string):
        if (object_class and key_string and (key_string != "NOTSET")):
            object = \
                SchoolDB.utility_functions.get_instance_from_key_string(
                key_string, object_class)
            if (not object):
                self.error_string = \
                    "%s instance could not be found." %self.target_class
                raise AjaxError,  self.error_string
        else:
            object = None
        return object
        
    def _select(self):
        """
        Process an ajax request for a selection list to be returned via json.
        """
        query = SchoolDB.assistant_classes.QueryMaker(self.target_class,
                                            self._build_query_descriptor())
        if (self.argsDict.has_key("names_only")):
            result_list, key_list, combined_list, message_text = \
                       query.get_keys_and_names()
        else:
            object_list, extra_data, message_text = query.get_objects()        
            result_list, key_list, combined_list = \
                query.get_keys_names_fields_from_object_list(object_list,
                    extra_fields = self.extra_fields, 
                    special_format = self.argsDict.get("format", None))
        self.return_string = simplejson.dumps(combined_list)
        return result_list

    def _select_via_function(self):
        """
        Use a named function to create the selection list. The function
        is returned by _get_mapped_function. The function returns the 
        combined list in the form used by autocomplete.
        """
        function = self._get_mapped_function()
        result_list, key_list, combined_list = function(self.argsDict)
        self.return_string = simplejson.dumps(combined_list)
        return result_list
    
    def select_from(self):
        """
        Select an object of a different class to be used as a selector
        itself in another action -- for example choose a class for
        grades work.
        """
        self._select_table()
        
    def _select_table(self):
        """
        Use the data from a select to generate a table in the form
        to be used by the google table widget. This has two major blocks,
        a list of entity keys for each row and the table itself.
        """
        
        query = SchoolDB.assistant_classes.QueryMaker(self.target_class,
                                            self._build_query_descriptor())
        object_list, extra_data, message_text = query.get_objects()        
        self._produce_table_from_object_list(object_list, extra_data)
        
    def _generated_object_table(self):
        """
        Use a function to generate the information for the table. The
        function name is included in the request. If the
        "class_function" parameter is included in the request use the
        object instance with the function name to create the function
        call; if "static_function" then use the secondary class to
        create the call. The class name for the static function should
        be fully defined. If neither flag is defined then use a
        straight function call, again with the full path. The function
        should return a list of objects to be further processed for
        display by the query.get_keys_names_fields.
        All function calls include this object.
        """
        function = self._get_mapped_function()
        secondary_key = SchoolDB.utility_functions.get_key_from_instance(
            self.secondary_object)
        object_list = function(self.argsDict, self.secondary_class,
                               secondary_key)
        self._produce_table_from_object_list(object_list)
    
    def _produce_table_from_object_list(self, object_list, extra_data = None):
        result_list, key_list, combined_list = \
            SchoolDB.assistant_classes.QueryMaker.get_keys_names_fields_from_object_list(object_list,
                extra_fields = self.extra_fields, 
                special_format = self.argsDict.get("format", None),
                no_key_in_list= True)
        columns = ["name"]
        columns.extend(self.extra_fields)
        table_description = []
        for field in columns:
            field_title = field.replace("_", " ")
            table_description.append((field, "string", 
                                      field_title.title())) 
        self._produce_table(table_description, result_list, key_list, 
                            extra_data)
        
    def _calculated_table(self):
        function = self._get_mapped_function()
        table_description, table_data, key_list, extra_data, error, = \
                         function(parameter_dict = self.argsDict, 
                                  primary_object = self.target_object,
                                  secondary_class = self.secondary_class,
                                  secondary_object = self.secondary_object)
        if (error):
            raise AjaxError, error
        self._produce_table(table_description, table_data, key_list, 
                            extra_data)
        
    def _produce_table(self, table_description, table_data, key_list, 
                           extra_data=None):
        json_table = self._make_table(table_description, table_data)
        json_key_list = simplejson.dumps(key_list)
        json_extra_data = simplejson.dumps(extra_data)
        json_combined = simplejson.dumps({
            "extraData":json_extra_data,
            "keysArray":json_key_list, 
            "tableDescriptor":json_table})
        self.return_string = json_combined
        
    def _set_single_value(self):
        #Set a value in an instance. No response required.
        if (self.target_class):
            value = simplejson.loads(self.argsDict.get("value",""))
            self.target_class.set_single_value(self.target_object,
                self.argsDict.get("value_name",""), value)

    def _children_list(self):
        if (self.target_object):
            query = SchoolDB.assistant_classes.QueryMaker(
                self.secondary_class, self._build_query_descriptor())
            query.ancestor = self.target_object
            object_list, extra_data, message_text = query.get_objects()
            self._process_object_list(object_list)
        else:
            self.error_string = "No usable parent instance could be found in this Ajax children_list request."
            raise AjaxError, self.error_string
    
    def _delete_instance(self):
        object_name = unicode(self.target_object)
        childrens_classes_string = self.argsDict.get(
            'childrens_classes', None)
        if (childrens_classes_string):
            childrens_classes = self.extra_fields
        else:
            childrens_classes = []
        SchoolDB.models.fully_delete_entity(self.target_object,
                                   childrens_classes, True)
        self.return_string = simplejson.dumps('"%s" deleted.'  
                                              %object_name)
        
    def _set_user_preferences(self):
        """
        Set preference values in the users database user object. 
        """
        if self.argsDict.has_key("user_preferences"):
            prefs = simplejson.loads(self.argsDict["user_preferences"])
            SchoolDB.models.getActiveDatabaseUser().get_active_user().set_private_info_multiple_values(prefs)
                   
    def _get_user_preferences(self):
        preferences = {}
        if self.argsDict.has_key("user_preferences"):
            pref_names = simplejson.loads(self.argsDict["user_preferences"])
            for value_name in pref_names:
                preferences[value_name] = \
                    SchoolDB.models.DatabaseUser.get_single_value(
                        None, value_name)
        self.return_string = simplejson.dumps(preferences)
        
    def _get_grades(self):
        """
        Process all request for grades or student class roster information.
        All of the functional code is in the AjaxGradeHandler class.
        """
        if (self.target_object):
            json_data = self.argsDict.get("encoded_data","")
            grade_handler = \
                SchoolDB.assistant_classes.AjaxGetGradeHandler(
                self.target_object, json_data)
            successful, self.return_string = \
                      grade_handler.service_request()
            if (not successful):
                self.error_string = "Grade load failed"
                raise AjaxError, self.error_string
        else:
            self.error_string = "Incorrect or missing class session db key."
            raise AjaxError, self.error_string                  

    def _set_grades(self):
        """
        Save grades for students in their StudentsClass object.
        The target_object is the class_period. There are four
        major pieces of data in the argsDict, all json strings.
        They are:
        1. "gi_keys" - a list of grading instance keys
        2. "student_keys" - a list of student instance keys
        3. "grade_table" - a two-d table of grade values
        4. "gi_changes" - a two level dictionary of values to be changed for
            each grading_instance. Top level keyed by grading instance, 
            second level by value name. May be None
        """
        if (self.target_object):
            return_data_json = self.argsDict.get('json_grades_data', None)
            if (return_data_json):
                return_data = simplejson.loads(return_data_json)
                gi_key_strings = return_data.get('columns', None)
                student_record_key_strings = \
                            return_data.get('keys', None)
                grades_table = return_data.get('data',None)
                student_class_records_encoded = return_data.get(
                    'json_student_records','[]')
                student_class_records_table = simplejson.loads(
                    student_class_records_encoded)
                json_gi_changes = self.argsDict.get('json_gi_changes', None)
                if json_gi_changes:
                    gi_changes = simplejson.loads(json_gi_changes)
                else:
                    gi_changes = {}
            if not (gi_key_strings and student_record_key_strings and
                    grades_table):
                raise AjaxError, \
                      "Missing some grades data. No grade information saved"
            if (len(gi_key_strings) and len(student_record_key_strings)):
                #if no gis or no student records nothing to do, 
                #but not really an error
                gi_changes = None
                grade_handler = \
                    SchoolDB.assistant_classes.AjaxSetGradeHandler(
                        student_grouping = self.target_object, 
                        gi_owner_type = self.secondary_class,
                        gi_owner = self.secondary_object,
                        gi_key_strings = gi_key_strings,
                        student_record_key_strings = \
                        student_record_key_strings,
                        grades_table = grades_table,
                        student_class_records_table = \
                        student_class_records_table,
                        gi_changes = gi_changes)
                successful, self.return_string = \
                          grade_handler.service_request()  
                logging.info("Save grades successful %s." %successful)
        else:
            self.error_string = \
                "No grades data. No grade information saved"
            raise AjaxError, self.error_string
            
    def _students_family_key(self):
        """
        Get the key for the family object from a student instance
        """
        student = self.target_object
        if (student):
            familyRef = student.family
            if (familyRef):
                familyKey = str(familyRef.key())
                self.return_string = simplejson.dumps(familyKey)
                
    def _students_family(self):
        """
        Get information about the students family. If the request
        parameter "relationship" = "family" then simply return the key
        for the students family. If it is "siblings" then return a list
        of keys and name of the siblings in the family or similarly for
        "parents".
        """
        relationship = self.argsDict["relationship"]
        family = self.target_object
        if (family):
            if (relationship == "family"):
                self.return_string = simplejson.dumps(str(family.key()))
            else:
                if (relationship == "siblings"):
                    relations_list = family.get_siblings()
                    #siblings_values_list = self._process_object_list(
                        #relations_list)
                    self._filter_out_object(relations_list,
                                            self.secondary_object)
                else:
                    relations_list = family.get_parents()
                self._produce_table_from_object_list(relations_list)
                
            
    def _create_family(self):
        """
        Create a family object and return its key for use in the web
        form.
        """
        family = SchoolDB.models.Family()
        name = self.argsDict.get("name","NOTSET")
        family.name = name
        family.put()
        self.return_string = simplejson.dumps(str(family.key()))

    def _cleanup_family(self):
        """
        A euphemistic way of saying delete the family object. It is
        named this to obfuscate the potential of deleting objects by
        ajax calls.
        """
        if (self.target_object):
            self.target_object.remove(True)
        
    def _suggest_siblings(self):
        """
        Return a list of students that might be a sibling of the
        student. These are simply students with the same last name.
        It is not an error if none exist.
        """
        query =  SchoolDB.assistant_classes.QueryMaker(
            SchoolDB.models.Student, self._build_query_descriptor())
        siblings_list, extra_data, message_text = query.get_objects()
        self._filter_out_object(siblings_list, self.target_object)
        self._produce_table_from_object_list(siblings_list)
        
    def _show_full_history(self):
        result = self.target_object.get_entries_tuples_list()
        self.return_string = simplejson.dumps(result)
        
    def _get_attendance(self):
        """
        Create a complete ajax response to a request for an attendance
        table. The request will have the student section as target_object
        and the end date as end_date in the dict.
        """
        if self.argsDict.get("end_date",None):
            d_array = simplejson.loads(
                self.argsDict.get("end_date",None))
            end_date=date(d_array[0],d_array[1],d_array[2])
        else:
            end_date = date.today()
        display_end_date = \
            SchoolDB.student_attendance.AttendanceTableCreator.compute_display_end_date(end_date)
        start_date = SchoolDB.student_attendance.AttendanceTableCreator.compute_default_start_date(display_end_date, 2)
        #get the list of all students who were in the section during the time of the attendance table period
        students = self.target_object.get_inclusive_student_list_for_period(
            start_date=start_date, end_date=end_date, 
             sort_by_gender = False)
        attendance_creator = \
            SchoolDB.student_attendance.AttendanceTableCreator(
                students=students, end_date=end_date, 
                section=self.target_object)
        table_descriptor = \
                attendance_creator.create_table_description()
        table_data = \
                attendance_creator.create_table_data()
        daytype_list = attendance_creator.dayperiod_type
        date_list = attendance_creator.date_list
        json_table = self._make_table(table_descriptor, table_data)
        student_key_strings = [str(student.key()) for student in students]
        json_key_list = simplejson.dumps(student_key_strings)
        json_daytype_list = simplejson.dumps(daytype_list)
        json_date_list = simplejson.dumps(date_list)
        json_header_string = simplejson.dumps(
            attendance_creator.generate_header_row())
        json_combined = simplejson.dumps({
            "keysArray": json_key_list, 
            "tableDescriptor": json_table,
            "dayTypeArray":json_daytype_list, 
            "generatedHeader":json_header_string,
            "dateArray":json_date_list})
        self.return_string = json_combined
    
    def _set_attendance(self):
        json_attendance_data = self.argsDict.get("json_attendance_data", None)
        if (json_attendance_data):
            attendance_data = simplejson.loads(json_attendance_data)
            data_processor = \
                SchoolDB.student_attendance.AttendanceResultsProcessor(
                    json_attendance_data = json_attendance_data,
                    section_name = attendance_data["section_name"]
                )
            data_processor.process_data_by_task()
            
    def _get_calendar(self):
        """
        Get information from the SchoolDay instances for the days
        requested and return in compact form. The dictionary keys are
        single letter ids: d:date, k:key, c:day_code, o:creating
        organization name, y:classyears i:information to be shown in
        info bubble. Empty classyears list means all.
        """
        dateArray = simplejson.loads(self.argsDict.get(
            "start_date", ""))
        start_date = date(dateArray[0],dateArray[1],dateArray[2])
        dateArray = simplejson.loads(self.argsDict.get(
            "end_date", ""))
        end_date = date(dateArray[0],dateArray[1],dateArray[2])
        datalist = []
        query = SchoolDB.models.SchoolDay.all(keys_only=True)
        query.filter("date >=", start_date)
        query.filter("date <=", end_date)
        query.order("date")
        day_keys = query.fetch(400)
        days = SchoolDB.models.SchoolDay.get(day_keys)
        for day in days:
            #convert for javascript 
            the_date = day.date
            converted_date = [int(the_date.strftime("%Y")), 
                               int(the_date.strftime("%m"))- 1,
                               int(the_date.strftime("%d"))]
            if (unicode(day.organization) != "National"):
                org = unicode(day.organization)
            else:
                org = ""
            #detailed information is the html that will be shown in the
            #tooltips bubble
            detailed_information = day.other_information
            if (not (day.first_year and day.second_year and day.third_year
                    and day.fourth_year)) :
                detailed_information += "<br>Only For:"
                if day.first_year:
                    detailed_information += "<br>&nbsp First Year"
                if day.second_year:
                    detailed_information += "<br>&nbsp Second Year"
                if day.third_year:
                    detailed_information += "<br>&nbsp Third Year"
                if day.fourth_year:
                    detailed_information += "<br>&nbsp Fourth Year"
            day_data = {"d":converted_date, "k":str(day.key()),
                        "c":day.day_type, "o":unicode(day.organization),
                        "i":detailed_information}
            datalist.append(day_data)
        self.return_string = simplejson.dumps(datalist)
    
    def _set_schoolday_date(self):
        """
        Change the date of a schoolday.
        """
        dt = simplejson.loads(self.argsDict.get("new_date", ""))
        new_date = date(dt[0],dt[1],dt[2])
        result_text, change_made = self.target_object.set_date(new_date, self)
        self.return_string = simplejson.dumps({"dialogText":result_text,
                                               "changeMade":change_made})
        
    def _get_achievement_test_grading_instances(self):
        """
        Return a list of keys of all of the grading instances in the 
        achievement test for the class year of the section.
        """
        instances = self.target_object.get_grading_instances(
            section = self.secondary_object)
        key_strings = []
        for instance in instances:
            key_strings.append(str(instance.key()))
        json_instances = simplejson.dumps(key_strings)
        return_data = {"gradingInstKeyArray":json_instances,
                       "studentRecordsArray":simplejson.dumps([])}
        self.return_string = simplejson.dumps(return_data)
    
    def _get_achievement_tests_for_section(self):
        """
        Use achievement test model function to provide a list of tests
        that have been taken this school year by a section. Return
        result in standard form choice list.
        """
        section_keystring = self.argsDict.get("filterkey-section", "")
        section = SchoolDB.utility_functions.get_instance_from_key_string(
            section_keystring)
        if section:
            tests = \
            SchoolDB.models.AchievementTest.findAchievementTestsForSection(
                    section)
        else:
            tests = []
        result_list, key_list, combined_list = \
            SchoolDB.assistant_classes.QueryMaker.get_keys_names_fields_from_object_list(tests)
        self.return_string = simplejson.dumps(combined_list)
        return result_list
    
    def _get_subjects_for_achievement_test(self):
        """
        Return the list of subjects from the achievement test instance.
        Note: TBD generalize this and the previous function
        """
        achievement_test_keystring = self.argsDict.get(
            "filterkey-achievement_test", "")
        achievement_test = \
            SchoolDB.utility_functions.get_instance_from_key_string(
                achievement_test_keystring)
        if (achievement_test):
            subject_keys = achievement_test.subjects
            subjects = [db.get(key) for key in subject_keys]
            
        else:
            subjects = []        
        result_list, key_list, combined_list = \
            SchoolDB.assistant_classes.QueryMaker.get_keys_names_fields_from_object_list(subjects)
        self.return_string = simplejson.dumps(combined_list)
        return result_list
        
            
    def _edit_grading_period_grades(self):
        """
        Return the table of grades for one or more grading periods.
        """
        edit_grading_periods = simplejson.loads(self.argsDict.get(
            "json_edit_grading_periods",'[]')) 
        view_grading_periods = simplejson.loads(self.argsDict.get(
            "json_view_grading_periods",'[]')) 
        students = simplejson.loads(self.argsDict.get(
            "json_student_list", '[]'))
        grading_period_table = simplejson.loads(self.argsDict.get("json_grades_data",'[]'))
        action = self.argsDict.get("action", "Get")
        grade_handler = SchoolDB.assistant_classes.GradingPeriodGradesHandler(
            self.target_object, edit_grading_periods, view_grading_periods,
            students, grading_period_table)
        if (action == "Set"):
            self.return_string = grade_handler.set_grades()
        else:
            self.return_string = grade_handler.get_grades()

    #rewrite
    def _get_gradebook_entries(self):
        """
        Get all gradebook entries for the specified class in a date range and
        return in compact form. The dictionary keys are single letter ids:
        d:date, k:key,c:gradebook entry type, g:grades are already recorded,
        i:information to be shown in info bubble
        """
        dateArray = simplejson.loads(self.argsDict.get(
            "start_date", ""))
        start_date = date(dateArray[0],dateArray[1],dateArray[2])
        dateArray = simplejson.loads(self.argsDict.get(
            "end_date", ""))
        end_date = date(dateArray[0],dateArray[1],dateArray[2])
        datalist = []
        class_session = SchoolDB.utility_functions.get_instance_from_key_string(
                        self.argsDict.get("class_session", ""), 
                        SchoolDB.models.ClassSession)
        if class_session:
            #NOTE:The next line does not filter by date. This must be rewritten.
            gradebook_entries = class_session.get_grading_instances()
            for entry in gradebook_entries:
                #convert for javascript 
                the_date = entry.date
                converted_date = [int(the_date.strftime("%Y")), 
                                   int(the_date.strftime("%m"))- 1,
                                   int(the_date.strftime("%d"))]
                grading_instance = entry.parent()            
                #"Name:\&nbsp%s<br>Type\&nbsp%s<br>\%\&nbspGrade:\&nbsp%f\%" \
                detailed_information = \
                "Type:&nbsp %s<br>%%&nbsp Total Grade:&nbsp %2.0f%%" \
                %(grading_instance.grading_type,
                  grading_instance.percent_grade)
                if (grading_instance.multiple):
                    detailed_information = detailed_information + \
                                         "<br>Multiple Entries"
                if (grading_instance.other_information):
                    detailed_information = detailed_information + \
                                         "<br>Other Details:&nbsp " + \
                                         grading_instance.other_information
                
                entry_data = {"d":converted_date, "k":str(entry.key()),
                              "n":grading_instance.name,
                            "c":grading_instance.get_classification(), 
                            "i":detailed_information,
                            "g":entry.grades_entered}
                datalist.append(entry_data)
        self.return_string = simplejson.dumps(datalist)

    def _change_date(self):
        """
        Shift the "date" value in the instance by delta_days. No 
        ajax return values other than call success is required.
        """
        delta_days_str = self.argsDict.get("delta_days", False)        
        if (delta_days_str):
            self.target_object.date = self.target_object.date + \
                timedelta(int(delta_days_str))
            self.target_object.put()
        
    def _find_similar_students(self):
        """
        Look for a possible reentry of the same student record. Several
        fields are compared to compute a score that indicates a
        possible match. The primary matches are last name and birthday
        if available.
        These fields should be sent in the request:
        first_name
        last_name
        community
        birthday
        """
        query = SchoolDB.models.Student.all(keys_only=True)
        organization = \
            SchoolDB.models.getActiveDatabaseUser().get_active_organization_key()
        query.filter("organization =", organization)
        query.filter("last_name =", self.argsDict["last_name"])
        matches = []
        match = None
        result = {}
        found_match = False
        student_keys = query.fetch(1000)
        students = db.get(student_keys)
        for student in students:
            score = 0
            if student.birthdate:
                birthdate_string = student.birthdate.strftime("%m/%d/%Y")
                if (birthdate_string == str(self.argsDict["birthdate"])):
                    score = 50
            if (student.first_name.lower() == \
                self.argsDict["first_name"].lower()):
                score += 50
            if (self.argsDict["community"]):
                community_key = SchoolDB.utility_functions.get_key_from_string(
                    self.argsDict["community"])
                if (student.community and 
                    student.community.key() == community_key):
                    score += 25
            if (score > 50):
                matches.append((student,score))
        #if more than one, choose highest score
        if (len(matches) > 0):
            match = matches[0][0]
            score = 0
            if (len(matches) > 1):
                for mt in matches:
                    if (mt[1] > score):
                        score = mt[1]
                        match = mt[0]
        if (match):
            found_match = True
            if (match.municipality):
                    municipality = unicode(match.municipality)
            else:
                municipality = "Unknown"
            if (match.community):
                community = unicode(match.community)
            else:
                community = "Unknown"
            if (match.birthdate):
                birthdate = match.birthdate.strftime("%m/%d/%Y")
            else:
                birthdate = "Unknown"
            dialog_html = """
                    <div id="contain" class="warning-window">
                <h2>Warning!</h2>
                <p>This student may already be in the database.</p>
                <p>The student's information is:</p>
                Name: %s %s<br/>
                Municipality: %s <br/>
                Barangay: %s <br/>
                Birthdate: %s <br/>
                <p>If this is the same student please <em>Do Not Save</em>. 
                Two entries for the same student can be a very big problem.</p>
                <p> Click the <em>"Cancel"</em> button at the bottom of the 
                entry page to return to the "Work With Students" page.
                Choose <em>"Edit"</em> and clear all boxes. Then type in
                "%s" in the Family Name box and select the student with 
                the same first name.
                If the student is the same then edit that record. </p>
                <p>Create a new student only after you have checked the 
                student record and you are know that
                this is a different student.</p>
                <p>Click <em>"Help"</em> for further information.</p>
                </div>                        
                """ %(match.first_name, match.last_name, municipality,
                      community,birthdate, match.last_name)
        else:
            dialog_html = ""
        return_data = {"FoundMatch":found_match, "dialogHtml":dialog_html}
        json_data = simplejson.dumps(return_data)
        self.return_string = json_data

    def _create_class_sessions(self):
        """
        Creating class sessions is a two step process. The initial
        request includes an array describing which classes are to be
        created. The response is a table with information about the
        classes to be created. The second request is the possibly
        edited table of classes that should be created. This is used to
        actually perform the creation. All logic is in the
        CreateClassSessions class.
        """
        return_data = \
            SchoolDB.system_management.BulkClassSessionsCreator.manage_creation(
            self.target_object, self.argsDict())
        json_data = simplejson.dumps(return_data)
        self.return_string = json_data        
        
    def _generate_dialog_content(self):
        """
        Process text from a versioned text page through a Django
        template and return the result for presentation. If text is
        included in the Ajax request it will be used instead of the
        text in the stored version so that the text may be tested
        before saving.
        """
        return_data = {}
        text_manager_name = self.argsDict.get("text_manager_name", None)
        if not text_manager_name:
            dialog_text="""
            Sorry. This help page is not yet written. 
            Click "View Manual" to see the entire manual.
            """
            return_data.update({"dialog_help":dialog_text, 
                       "balloon_help": {}})
            self.return_string = simplejson.dumps(return_data)
            return
        text_manager = SchoolDB.utility_functions.get_entities_by_name(
            SchoolDB.models.VersionedTextManager, text_manager_name,
            single_only=True)
        if not text_manager:            
            dialog_text="""
            Sorry. This help page could not be found. 
            Click "View Manual" to see the entire manual.
            """
            return_data.update({"dialog_help":dialog_text, 
                       "balloon_help": {}})
            self.return_string = simplejson.dumps(return_data)
            return
        template_type = self.argsDict.get("template_type", "Dialog")
        test_text = self.argsDict.get("test_text", None)
        revision_number = self.argsDict.get("revision_number", "current")
        help_dialog_page, ballon_help_dict = text_manager.get_processed_text(
            template_type, revision_number, test_text)
        return_data.update({"dialog_help":help_dialog_page, 
                       "balloon_help": ballon_help_dict})
        self.return_string = simplejson.dumps(return_data)
        
    def _unknown_action(self):
        raise AjaxError, 'Unknown ajax action request %s' %self.action
    
    def _get_additional_filters(self):
        """
        Values to be used in a query filter are returned with the
        prefix "filter-". Extract these from the argsDict, convert them
        to a form to be used in filtering and concat all into a list. A
        key for a filter may have a null item. This means that it was
        unset and should not be filtered upon. If so, do not create a
        filter for it.
        """
        filters = []
        for arg_key in self.argsDict.keys():
            if arg_key.startswith("filter-"):
                filter_param = arg_key.split("-")[1]
                filter_value = self.argsDict[arg_key]
                if (filter_value):
                    filter_value = convert_boolean_string(filter_value)
                    filters.append((filter_param, filter_value))
            elif arg_key.startswith("filterkey-"):
                filter_param = arg_key.split("-")[1]
                keystring = self.argsDict[arg_key]
                if (keystring):
                    filter_value = SchoolDB.utility_functions.get_key_from_string(
                        keystring)
                    if (filter_value and db.get(filter_value)):
                        #confirm that the key is valid -- a filter
                        #on a nonexistant key would end in a null set
                        #filtering
                        filters.append((filter_param, filter_value))
        return filters

    def _filter_out_object(self, objects_list, filter_object):
        """
        Scan a list of objects for the object key from the request.
        (the requester). Remove entry from list if found so that it
        will not be seen in a result list.
        """
        if filter_object:
            target_key = filter_object.key()
            for i in range(0,len(objects_list)):
                if (objects_list[i].key() == target_key):
                    del objects_list[i]
                    break
                    
    def _process_object_list(self, object_list):
        """
        Process the object_list and set self.return_string to the json
        for the result. Return a list of the object values for use
        in further filtering
        """
        result_list, key_list, combined_list = \
            SchoolDB.assistant_classes.QueryMaker.get_keys_names_fields_from_object_list(
            object_list, False, self.extra_fields)
        if (len(result_list) > 0):
            self.return_string = simplejson.dumps(result_list)
        return result_list
    
    def _make_table(self, table_description, table_data):
        """
        Create the ajax return value for a full table representation
        with the Google table.
        """
        data_table = SchoolDB.gviz_api.DataTable(table_description)
        data_table.LoadData(table_data)
        json_table = data_table.ToJSon()
        return json_table

    def _build_query_descriptor(self):
        """
        Create a dictionary of parameters to be used by a MakeQuery
        object to create an object list from a database query. Note
        that an important parameter filter_by_organization needs
        argument to disable it because it is used by default.
        """
        #create intial framework with defaults
        descriptor = SchoolDB.assistant_classes.QueryDescriptor()
        #if there is a key for the leading value, then add filter
        lv_field = ""
        if (self.argsDict.has_key("q")):
            if (self.argsDict.has_key("leading_value_field")):
                lv_field = self.argsDict["leading_value_field"]
            elif (self.target_class.properties().has_key("last_name")):
                lv_field = "last_name"
            else:
                lv_field = "name"
            descriptor.set("leading_value",(lv_field, 
                                             self.argsDict["q"]))
        descriptor.set("filters",self._get_additional_filters())
        descriptor.set("ancestor_filter_value",
                    self.argsDict.get("parent", None))
        sort_order = self.argsDict.get("sort",[])
        if (len(sort_order) == 0):
            x = self.target_class.properties()
            if (self.target_class.properties().has_key("last_name")):
                #this is probably some type of person so sort a normal
                #way for a person
                sort_order = ["last_name", "first_name"]
            elif (self.target_class.properties().has_key("name")):
                #most classes have a "name" as the primary identifier 
                #so sort on it
                sort_order = ["name"]
        descriptor.set("sort_order", sort_order)
        if (self.argsDict.has_key("use_class_query")):
            descriptor.set("use_class_query", True)
        if (self.argsDict.has_key("ignore_organization")):
            descriptor.set("filter_by_organization", False)
        if (self.argsDict.has_key("maximum_count")):
            descriptor.set("maximum_count", 
                           self.argsDict["maximum_count"])
        return descriptor
            
    def _get_mapped_function(self):
        """
        This will return the fully mapped and qualified function from
        the arguments in the Ajax request. While rather inflexible and
        difficult for arbitrary on-the-fly enhancement like "eval" it
        provides the very strictly limited set of requestable functions
        that is necessary for security with a web application. All
        functions listed here take the args_dict as the only argument.
        Each of these functions should be written to support the Ajax
        request. These may often just be wrappers around another common
        function.Only one call to a function in this table can be
        performed in an Ajax request. Arbitrary chaining is not
        supported to prevent a potentially unsafe combination of
        functions by an unsecured Ajax request.
        
        The function name is included in the request as
        "function_name". The name is unique for every function that can
        be called. If the function is a class function then
        self.target_object is used as the object in the call. All of
        the mapping is done in this table with fully qualified function
        names for static class functions or simple functions. While all
        of the functions are in different files they are defined here
        both for correct qualification and ease of finding the mapping.
        This table must be extended as necessary to include further
        external functions. The functions defined here should be safe
        ones like report generation that will not require tight control
        of actions so that they should be filtered before ever reaching
        ajax.
        
        This table can be viewed as the "traffic cop" or "firewall" for
        functions called via Ajax.
        """
        if (not self.function_name):
            self.error_string = "Function name missing."
            raise AjaxError, self.error_string
                        
        obj = self.target_object
        if (self.function_name == "update_object_list"):
            #if the target object is the database user use the current
            #database user to prevent hacked access to another user
            if (self.target_class == SchoolDB.models.DatabaseUser):
                obj = SchoolDB.models.getActiveDatabaseUser().get_active_user()
            function = obj.update_object_list
        elif (self.function_name == "create_section_students_table"):
            function = SchoolDB.views.create_section_students_table
        elif (self.function_name == "create_class_session_students_table"):
            function = SchoolDB.views.create_class_session_students_table
        elif (self.function_name == "create_section_classes_table"):
            function = SchoolDB.views.create_section_classes_table
        elif (self.function_name == "create_attendance_report_table"):
            function = SchoolDB.student_attendance.AttendanceReports.create_report_table
        elif (self.function_name == "create_student_age_report_table"):
            function = SchoolDB.reports.StudentAgeReport.create_report_table
        elif (self.function_name == "create_student_register_report_table"):
            function = SchoolDB.reports.SchoolRegisterReport.create_report_table
        elif (self.function_name == "create_section_list_report_table"):
            function = SchoolDB.reports.SectionListReport.create_report_table
        elif (self.function_name == "create_student_record_check_table"):
            function = SchoolDB.reports.StudentRecordCheck.create_report_table
        elif (self.function_name == 
              "create_students_eligible_for_class_table"):
            function = \
                SchoolDB.views.create_students_eligible_for_class_table
        elif (self.function_name == 
              "create_grading_period_grades_table"):
            function = \
                    SchoolDB.reports.SectionGradingPeriodGradesTable.create_report_table
        elif (self.function_name == "create_form2_table"):
            function = \
                SchoolDB.student_attendance.Form2Report.create_report_table
        elif (self.function_name == "create_form14_table"):
            function = \
                SchoolDB.reports.Form14Report.create_report_table
        elif (self.function_name == "create_student_summary_table"):
            function = \
                SchoolDB.reports.StudentSummaryReport.create_report_table
        elif (self.function_name == "create_achievement_test_summary"):
            function = \
                SchoolDB.reports.AchievementTestReport.create_report_table
        elif (self.function_name == "create_encoding_check_table"):
            function = \
                SchoolDB.reports.EncodingCheck.create_report_table
        elif (self.function_name == 
              "get_completed_grading_periods_selection_list"):
            function = \
                SchoolDB.models.GradingPeriod.get_completed_grading_periods_selection_list
        else: 
            function = None
        #It is assumed that the function is always needed. If it is
        #not defined raise an error
        if (not function):
            self.error_string = \
                  "Function %s not defined." %self.function_name
            raise AjaxError, self.error_string
        return function

    def _return_ajax_permissions_error(self, error_string_suffix):
        """
        Return an error message with the result code 403 to indicate
        response forbidden. This is called by ProhibitedError exceptions
        that are raised during security testing.
        """
        error_string = "Sorry, you may not " + error_string_suffix
        #this will need to be changed whem the 403 page is built
        return http.HttpResponseForbidden(error_string)

def convert_boolean_string(string_val):
    """
    Booleans are sent as strings so they need conversion. If the
    string is "true" or "false" then return boolean value. Pass
    through unchanged otherwise. This is safe to use with any string.
    """
    test_val = string_val.lower()
    if not (test_val == "true" or test_val == "false"):
        return string_val
    else:
        return (test_val == "true")

            
